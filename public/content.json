[{"title":"Javascript-note","date":"2017-02-22T13:57:57.000Z","path":"2017/02/22/Javascript-note/","text":"学习javascript的笔记balabla","tags":[{"name":"javascript","slug":"javascript","permalink":"https://juncaixinchi.github.io/Blogs/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://juncaixinchi.github.io/Blogs/tags/ES6/"}]},{"title":"Simple-Canvas-Game","date":"2017-02-18T15:10:08.000Z","path":"2017/02/18/Simple-Canvas-Game/","text":"利用HTML5 Canvas制作小游戏的简单教程，详见 simple_canvas_game1. 创建一个Canvas对象123456// Create the canvasvar canvas = document.createElement(\"canvas\");var ctx = canvas.getContext(\"2d\");canvas.width = 512;canvas.height = 480;document.body.appendChild(canvas);我们首先要做的是创建一个canvas对象。可以用JavaScript或HTML来做，都非常简单。此处我用的是JS。当创建了canvas之后，我们就可以获取它的上下文对象（context）、设置尺寸，并且把它加到当前文档中。2. 载入图片1234567// Background imagevar bgReady = false;var bgImage = new Image();bgImage.onload = function () &#123; bgReady = true;&#125;;bgImage.src = \"images/background.png\";游戏需要图像，所以让我们载入一些图片吧。我想尽量简单化，所以只用了Image对象来做，当然，还可以将载入图像的功能封装成一个类或别的任何形式。代码中的bgReady用来标识图片是否已完全载入，只有当图片载入完成后，我们才能使用它，如果在载入完成前就对其进行绘制或渲染，JS将会报一个DOM error的错误。我们会用到三张图片（背景、英雄、怪物），每张图片都需要这样处理。3. 定义游戏要使用的对象1234567891011// Game objectsvar hero = &#123; speed: 256, // movement in pixels per second x: 0, y: 0&#125;;var monster = &#123; x: 0, y: 0&#125;;var monstersCaught = 0;定义一些变量，稍后会用到。hero对象的speed属性表示英雄的移动速度（像素/秒）；monster对象不会移动，所以仅仅具有一对坐标；monstersCaught表示玩家抓住的怪物数量。4. 处理玩家输入12345678// Handle keyboard controlsvar keysDown = &#123;&#125;;addEventListener(\"keydown\", function (e) &#123; keysDown[e.keyCode] = true;&#125;, false);addEventListener(\"keyup\", function (e) &#123; delete keysDown[e.keyCode];&#125;, false);现在进行输入的处理。（对具有web开发背景的人来说，这是目前为止第一个具有挑战性的部分）对一般的网页来说，当用户开始输入时，可能需要马上开始播放动画或请求数据。但在这里，我们想让游戏逻辑在一个单独的地方对游戏中发生的事情进行处理。为此我们需要将用户输入保存下来以备稍后处理，而不是立即处理。我们通过简单地将事件对应的键编码（keyCode）保存在keysDown变量中来实现。如果该变量中具有某个键编码，就表示用户目前正按下这个键。简单吧！5. 新游戏123456789// Reset the game when the player catches a monstervar reset = function () &#123; hero.x = canvas.width / 2; hero.y = canvas.height / 2; // Throw the monster somewhere on the screen randomly monster.x = 32 + (Math.random() * (canvas.width - 64)); monster.y = 32 + (Math.random() * (canvas.height - 64));&#125;;通过调用reset函数来开始新游戏。该函数将英雄（即玩家角色）放到屏幕中间，然后随机选择一个位置来安置怪物。6. 更新对象1234567891011121314151617181920212223242526// Update game objectsvar update = function (modifier) &#123; if (38 in keysDown) &#123; // Player holding up hero.y -= hero.speed * modifier; &#125; if (40 in keysDown) &#123; // Player holding down hero.y += hero.speed * modifier; &#125; if (37 in keysDown) &#123; // Player holding left hero.x -= hero.speed * modifier; &#125; if (39 in keysDown) &#123; // Player holding right hero.x += hero.speed * modifier; &#125; // Are they touching? if ( hero.x &lt;= (monster.x + 32) &amp;&amp; monster.x &lt;= (hero.x + 32) &amp;&amp; hero.y &lt;= (monster.y + 32) &amp;&amp; monster.y &lt;= (hero.y + 32) ) &#123; ++monstersCaught; reset(); &#125;&#125;;这是update函数，游戏每隔一定时间会调用它一次。它所做的第一件事情是检查用户是否按下了上下左右四个箭头键。如果是，就将我们的英雄向相应的方向移动。update有一个modifier参数，这看起来好像有点奇怪。你会在游戏的主函数即main函数中看到它，不过我在这儿先解释一下。modifier参数是一个从1开始的与时间相关的数。如果间隔刚好为1秒时，它的值就会为1，英雄移动的距离即为256像素（英雄的速度为256像素/秒）；而如果间隔是0.5秒，它的值就为0.5，即英雄移动的距离为其速度的一半，以此类推。通常update函数调用的间隔很短，所以modifier的值很小，但用这种方式能够确保不管代码执行的速度怎么样，英雄的移动速度都是相同的。我们已经实现了根据用户的输入来移动英雄，但我们还可以在移动英雄时对其进行检查，以确定是否有其他事件发生。例如：英雄是否与怪物发生了碰撞——当英雄与怪物发生碰撞时，我们为玩家进行计分（monstersCaught加1）并重置游戏（调用reset函数）。7. 渲染对象123456789101112131415161718192021// Draw everythingvar render = function () &#123; if (bgReady) &#123; ctx.drawImage(bgImage, 0, 0); &#125; if (heroReady) &#123; ctx.drawImage(heroImage, hero.x, hero.y); &#125; if (monsterReady) &#123; ctx.drawImage(monsterImage, monster.x, monster.y); &#125; // Score ctx.fillStyle = \"rgb(250, 250, 250)\"; ctx.font = \"24px Helvetica\"; ctx.textAlign = \"left\"; ctx.textBaseline = \"top\"; ctx.fillText(\"Goblins caught: \" + monstersCaught, 32, 32);&#125;;当你能够看到你的行动时游戏才会变得更有趣，所以让我们在屏幕上绘制吧。首先我们将背景图片绘制到canvas，然后是英雄和怪物。注意顺序很重要，因为任何位于表层的图片都会将其下面的像素覆盖掉。接下来是文字，这有些不同，我们调用fillText函数显示玩家的分数。因为不需要复杂的动画或者对文字进行移动，所以只是绘制一下就ok了。8. 游戏主循环12345678910// The main game loopvar main = function () &#123; var now = Date.now(); var delta = now - then; update(delta / 1000); render(); then = now;&#125;;游戏的主循环用来控制游戏流程。首先我们要获得当前的时间，这样我们才能计算时间差（自上次循环以来经过的时间）。然后计算modifier的值并交给update（需要将delta除以1000以将其转换为毫秒）。最后调用render并更新记录的时间。更多关于游戏循环的内容见“Onslaught! Arena Case Study”。9. 开始游戏吧1234// Let's play this game!reset();var then = Date.now();setInterval(main, 1); // Execute as fast as possible快完成了，这是最后一段代码。首先调用reset来开始新游戏。（还记得吗，这会将英雄置中并随机安放怪物）。然后将起始时间保存到变量then中并启动游戏的主循环。OK！（但愿）你现在已经理解了在HTML5 Canvas中用JS来开发游戏的基础知识了。建议最好是能够自己亲自试一把！","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://juncaixinchi.github.io/Blogs/tags/Canvas/"},{"name":"Game","slug":"Game","permalink":"https://juncaixinchi.github.io/Blogs/tags/Game/"},{"name":"Demo","slug":"Demo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Demo/"}]},{"title":"Git_note","date":"2017-02-14T11:36:07.000Z","path":"2017/02/14/Git-note/","text":"Git note学习Git的笔记，完整文档见Git-scmGit 配置获取升级$ git clone git://git.kernel.org/pub/scm/git/git.git 添加用户信息，并查看配置文件$ git config --global user.name &quot;juncaixinchi&quot; $ git config --global user.email &quot;juncaixinchi111@gmail.com&quot; $ less ~/.gitconfig 获取帮助$ git help &lt;verb&gt; $ git &lt;verb&gt; --help $ man git-&lt;verb&gt; 生成ssh keys，在Github-keys添加即可$ ssh-keygen -t rsa -b 4096 -C &quot;juncaixinchi111@gmail.com&quot; $ clip &lt; ~/.ssh/id_rsa.pub Git 基础在现有目录中初始化仓库$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。$ git add * $ git commit -m &apos;initial project version&apos; 在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，应该开始跟踪这些文件并提交。克隆现有的仓库克隆blog-generater至当前目录，分别使用HTTPS协议、SSH协议、本地协议$ git clone https://github.com/juncaixinchi/blog-generater.git $ git clone git@github.com:juncaixinchi/blog-generater.git $ git clone /opt/git/project.git 记录每次更新到仓库$ git add README 使用命令 git add 开始跟踪跟踪 README 文件$ git status $ git status -s 检查当前文件状态，加-s为简略信息忽略文件创建一个名为 .gitignore 的文件，列出要忽略的文件模式，文件 .gitignore 的格式规范如下：所有空行或者以 ＃ 开头的行都会被 Git 忽略。要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。# no .a files *.a 匹配模式可以以（/）开头防止递归。# only ignore the TODO file in the current directory, not subdir/TODO /TODO 匹配模式可以以（/）结尾指定目录。# ignore all files in the build/ directory build/ 可以使用标准的 glob 模式匹配。# ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 提交更新commit命令会提交更新，-m参数可添加提交备注，或者随机生成备注 O__O$ git commit -m &quot;update&quot; $ git commit -m &quot;`curl -s http://whatthecommit.com/index.txt`&quot; 给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 add 步骤$ git commit -a -m &apos;update without git add&apos; 不过正式的提交还是应该避免-m 添加备注，而是详细的添加移除文件或移动文件使用 rm 命令将文件从已跟踪文件清单中移除，并连带从工作目录中删除指定的文件，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f$ git rm file_to_remove.md $ git mv file_from file_to 查看提交历史查看所有log$ git log 显示最近两次提交的差异$ git log -p -2 显示每次提交的简略的统计信息$ git log --stat 以pretty的方式显示提交历史$ git log --pretty=oneline 添加了一些ASCII字符串来形象地展示你的分支、合并历史：$ git log --pretty=format:&quot;%h %s&quot; --graph 只显示作者L在2周内提交的近5条记录$ git log --author L --since=2.weeks -5 撤消操作尝试重新提交,第二次提交将代替第一次提交的结果$ git commit -m &apos;initial commit&apos; $ git add forgotten_file $ git commit --amend 取消暂存的文件file_to_cancle.txt(git add 的相反操作)$ git reset HEAD file_to_cancle.txt 撤消对文件的修改，恢复文件file_to_restore.txt到上次提交时候的状态$ git checkout -- file_to_restore.txt 远程仓库的使用查看远程仓库$ git remote -v $ git remote show 添加远程仓库，默认为 origin$ git remote add &lt;shortname&gt; &lt;url&gt; $ git remote add pd https://github.com/juncaixinchi/blog-generater.git 从远程仓库中抓取，默认从origin抓取，也可自定义$ git fetch $ git fetch https://github.com/juncaixinchi/blog-generater.git $ git fetch origin master:tmp git fetch不会自动merge，需再merge$ git fetch origin master:tmp $ git diff tmp $ git merge tmp 直接从远程获取最新版本并merge到本地$ git pull origin master 使用 git push (remote) (branch)推送到远程仓库，默认推送到origin/master, 也可自定义远程仓库及分支（如serverfix）$ git push $ git push https://github.com/juncaixinchi/blog-generater.git $ git push origin serverfix $ git push origin serverfix:awesomebranch 设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支$ git checkout --track origin/serverfix 远程仓库的移除和重命名$ git remote rm paul $ git remote rename pb paul 删除远程分支serverfix$ git push origin --delete serverfix 打标签列出已有标签$ git tag 创建一个附注标签，指定提交的校验和（或部分校验和）则可后期打标签$ git tag -a v1.4 -m &apos;my version 1.4&apos; $ git tag -a v0.0 -m &quot;origin version&quot; c76e548 共享标签$ git push origin v1.5 设置别名通过 config 为命令设置别名，外部程序的命令则要加!，使用cmu直接add 及 commit$ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.st status $ git config --global alias.last &apos;log -1 HEAD&apos; $ git config --global alias.hexo &apos;!hexo g -delpoy&apos; $ git config --global alias.cmu &apos;commit -a -m &quot;update&quot;&apos; $ git config --global alias.logbr &apos;log --oneline --decorate --graph --all -20&apos; Git 分支分支的新建和合并创建分支testing，分支切换为testing，然后commit内容将在test分支进行$ git branch testing $ git checkout testing 或者在过去某个版本，如593015f,建立分支testing$ git log --oneline --decorate --graph --all $ git checkout 593015f $ git checkout -b testing 使用 log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 –decorate。$ git log --oneline --decorate $ git log --oneline --decorate --graph --all 使用 merge 来合并分支$ git merger testing 如果 master 和 testing 分支都各有提交新版本，则无法自动合并，会出现如下错误，需要手动编辑冲突的文件，然后再 commit，Auto Merge Failed; Fix Conflicts and Then Commit the Result 例如冲突的文件内容为：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; testing:index.html 这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置）在这个区段的上半部分（======= 的上半部分），而 testing 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，必须选择使用由 ======= 分割的两部分中的一个，或者也可以自行合并这些内容。 例如，通过把这段内容换成下面的样子来解决冲突：&lt;div id=&quot;footer&quot;&gt; please contact us at email.support@github.com &lt;/div&gt; 另外也可以使用图形化工具来解决冲突$ git mergetool 合并完成后删除分支testing$ git branch -d testing 分支的管理显示分支列表$ git branch 查看每一个分支的最后一次提交$ git branch -v 查看已经合并或尚未合并到当前分支的分支$ git branch --merged $ git branch --no-merged 删除和强制删除分支$ git branch -d testing $ git branch -D testing 分支整合之变基使用 rebase 命令将提交到某一分支 testing 上的所有修改都移至另一分支 master 上，然后回到 master 分支，进行一次快进合并。$ git checkout testing $ git rebase master $ git checkout master $ git merge testing 直接将特性分支（testing）变基到目标分支（即 master）上$ git rebase master testing 对两个分支进行变基时，将 client 中的修改合并到主分支并发布，但暂时并不合并 server 中的修改$ git rebase --onto master server client 变基的风险：不要对在仓库外有副本的分支执行变基Git工具子模块将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。$ git submodule add git@github.com:juncaixinchi/hexo-theme-next.git themes/next $ git submodule init $ git submodule update $ git submodule update themes/next 在开始克隆含有子模块的仓库时，可添加–recursive，直接递归添加所有子模块$ git clone --recursive https://github.com/juncaixinchi/blog-generater.git 让 Git 在推送到主项目前检查所有子模块是否已推送$ git push --recurse-submodules=check 让 Git 自动进入到子模块中，然后在推送主项目前推送了它$ git push --recurse-submodules=on-demand 遍历子模块运行命令$ git submodule foreach &apos;git push&apos; 调试通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。开始二分查找，并设置当前版本为有问题状态$ git bisect start $ git bisect bad 设定没有问题的版本，然后依次检测个版本，设定 bad or good ，直到找到问题版本$ git bisect good v1.0 完成后，重置 HEAD 指针到最开始的位置$ git bisect reset 标注任何文件的行，指出文件的每一行的最后的变更的提交及谁是那一个提交的作者，通过-L来限定行数$ git blame $ git blame -L 12,22 file_to_check 在源代码中，甚至是你项目的老版本中的任意文件中查找任何字符串或者正则表达式$ git grep 维护项目balabala…","tags":[{"name":"Github","slug":"Github","permalink":"https://juncaixinchi.github.io/Blogs/tags/Github/"},{"name":"Git","slug":"Git","permalink":"https://juncaixinchi.github.io/Blogs/tags/Git/"}]},{"title":"基于Hexo+Next+GitHub搭建个人博客","date":"2017-02-14T08:24:56.000Z","path":"2017/02/14/Blog-driven-by-hexo/","text":"基于Hexo+Next+GitHub搭建个人博客简介Hexo是依赖于node.js的个人博客生成引擎，可以把基于Markdown的文件生成博客页面，所以整个项目分为两部分：网页生成安装配置Hexo及其主题Next，撰写整理博客文档，生成静态页面 blog-generater网页部署生成的网页存在于public文件夹内，将其部署到Github Pages或其他服务器即可 Blogs安装和配置首先要有node.js，然后用npm安装hexo$ npm install -g hexo-cli 切换到博客的位置$ cd ~/Github/ 生成新的博客文件夹，这会需要一段时间$ hexo init blog $ cd blog 开启服务器，默认为 http://127.0.0.1:4000/ 可在本地查看$ hexo server 生成新的文章，这里”Hello Hexo”只是标题，然后可以编辑Hello-Hexo.md撰写博客$ vi ./source/_posts/Hello-Hexo.md 生成静态文件，以便部署到Github Pages，详细配置见下文$ hexo generate $ hexo deploy 或者合并$ hexo generate --deploy 安装压缩页面的插件$ npm install hexo-all-minifier --save 自动生成静态页面和部署安装 hexo-deployer-git.$ npm install hexo-deployer-openshift --save 编辑配置文件，需在github先新建repository：Blogsdeploy: type: git repo: git@github.com:juncaixinchi/Blogs.git branch: master 生成静态文件和自动部署hexo generate --deploy 配置与添加主题在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。设置网站路径很关键，否则上传至GitHub不能正确加载css和jsurl: https://juncaixinchi.github.io/Blogs/ root: /Blogs/ 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans 设置 头像将avatar.png放置在 source/images/ 目录下，站点配置文件新增字段 avatar，配置为：avatar: /images/avatar.png 安装主题因为添加主题next，在上传GitHub Pages的时候遇到了以下问题：Page build failed: Missing submodule 发现是submodule没有配置好，删除原来的 themes/next/ 文件使用以下代码重新配置$ git submodule add git@github.com:juncaixinchi/hexo-theme-next.git themes/next $ git submodule init $ git submodule update 选择主题SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。#scheme: Muse #scheme: Mist scheme: Pisces 添加标签云页面新建一个页面，命名为 tags 。命令如下：hexo new page &quot;tags&quot; 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云，如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：title: All tags date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 在菜单中添加链接。编辑主题的 _config.yml ，添加 tags 到 menu 中，如下:menu: home: / archives: /archives tags: /tags 404页面设置设置腾讯的404公益页面，在source/下添加404.html12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"all\" /&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://juncaixinchi.github.io/Blogs/\" homePageName=\"回到我的主页\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;但是该页面使用http获取js，且其中嵌入的各种链接都是http，而Github要求全部为https。故修改代码（见下面）。其中search_children.js主要提取了data.js及page.js两个文件，前者是寻找儿童的数据，在Github中没问题；后者中默认都是用http加载的js和css，所以不能直接用，故本地化后修改为https方式获取js与css。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"all\" /&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://juncaixinchi.github.io/Blogs/\" homePageName=\"回到我的主页\"&gt; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"404/page.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;添加404目录hexo new page &quot;404&quot; 在source/404/，添加新文件search_children.js，内容为：12var _base = 'https://qzone.qq.com/gy/404/';document.write('&lt;script type=\"text/javascript\" src=\"' + _base + 'data.js\" charset=\"utf-8\"&gt;&lt;/script&gt;');添加新文件page.js，主要是修改了 qzone_page.js 内容中外联js和css的链接，将 “http://“ 改为 “https://“ ，内容详见：local_page.js然后生成文件hexo generate 然而发现问题还没解决，debug N 久后发现，hexo自动生成public文件时，会对page.js处理一下，其中第297行：c += &quot;&lt;&quot; + d + &quot;&gt;\\n&quot; + a[d] + &quot;\\n\\n&quot;; 变成了以下内容，然后报错(&gt;_&lt;)c += &quot;&lt;&quot; +=&quot;&quot; d=&quot;&quot; &quot;=&quot;&quot;&gt;\\n&quot; + a[d] + &quot;\\n\\n&quot;; 暂时未知原因，只好手动替换page.js解决之cp source/404/page.js public/404/page.js 顺便也可替换404.html，可以避免一次跳转cp source/404.html public/404.html 然后上传部署，OKhexo deploy","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Hexo/"},{"name":"next","slug":"next","permalink":"https://juncaixinchi.github.io/Blogs/tags/next/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://juncaixinchi.github.io/Blogs/tags/GitHub-Pages/"},{"name":"blog","slug":"blog","permalink":"https://juncaixinchi.github.io/Blogs/tags/blog/"}]},{"title":"Github Git Cheat Sheet","date":"2017-02-12T08:42:19.000Z","path":"2017/02/12/Github-Git-Cheat-Sheet/","text":"GitHub Git 备忘单要点git add * 将所有文件进行快照处理用于版本控制git commit -m &quot;upload files&quot; 将文件快照永久地记录在版本历史中git push 上传所有本地分支commit到GitHub上详细内容Git是一个开源的分布式版本控制系统，方便你在笔记本或桌面端进行GitHub的操作，这个备忘单总结了常用的Git命令行指令，以便快速查询。转载自 https://services.github.com/on-demand/downloads/zh_CN/github-git-cheat-sheet/安装GitGitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。GitHub for Windowshttp://windows.github.comGitHub for Machttp://mac.github.comGitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取。Git 全平台版http://git-scm.com配置工具对所有本地仓库的用户信息进行配置$ git config --global user.name &quot;[name]&quot; 对你的commit操作设置关联的用户名$ git config --global user.email &quot;[email address]&quot; 对你的commit操作设置关联的邮箱地址创建仓库创建一个新的仓库或者从一个现有的链接获取仓库$ git init [project-name] 创建一个本地的仓库，并设置名字$ git clone [url] 下载一个项目以及它所有的版本历史更改检查已有的编辑并执行commit操作$ git status 列出所有新建或者更改的文件，这些文件需要被commit$ git diff 展示那些没有暂存文件的差异$ git add [file] 将文件进行快照处理用于版本控制$ git diff --staged 展示暂存文件与最新版本之间的不同$ git reset [file] 将文件移除暂存区，但是保留其内容$ git commit -m&quot;[descriptive message]&quot; 将文件快照永久地记录在版本历史中批量更改命名一系列commit以及合并已完成的工作$ git branch 列出当前仓库中所有的本地分支$ git branch [branch-name] 建立一个新分支$ git checkout [branch-name] 切换到一个特定的分支上并更新工作目录$ git merge [branch-name] 合并特定分支的历史到当前分支$ git branch -d [branch-name] 删除特定的分支重构文件重定位并移除版本文件$ git rm [file] 从工作目录中删除文件并暂存此删除$ git rm --cached [file] 从版本控制中移除文件，并在本地保存文件$ git mv [file-original] [file-renamed] 改变文件名并准备commit停止追踪不包含临时文件和路径*.log build/ temp-* 文本文件.gitignore可以防止一些特定的文件进入到版本控制中$ git ls-files --others --ignored --exclude-standard 列出所有项目中忽略的文件保存临时更改暂存一些未完成的更改$ git stash 临时存储所有修改的已跟踪文件$ git stash pop 重新存储所有最近被stash的文件$ git stash list 列出所有被stash的更改$ git stash drop 放弃所有最近stash的更改查阅历史浏览并检查项目文件的发展$ git log 列出当前分支的版本历史$ git log --follow [file] 列出文件的版本历史，包括重命名$ git diff [first-branch]...[second-branch] 展示两个不同分支之间的差异$ git show [commit] 输出元数据以及特定commit的内容变化撤销commit擦除错误并更改历史$ git reset [commit] 撤销所有[commit]后的的commit，在本地保存更改$ git reset --hard [commit] 放弃所有更改并回到某个特定的commit同步更改注册一个远程的链接，交换仓库的版本历史$ git fetch [remote] 下载远程仓库的所有历史$ git merge [remote]/[branch] 合并远程分支到当前本地分支$ git push [remote] [branch] 上传所有本地分支commit到GitHub上$ git pull 下载书签历史并合并更改","tags":[{"name":"git","slug":"git","permalink":"https://juncaixinchi.github.io/Blogs/tags/git/"},{"name":"Github","slug":"Github","permalink":"https://juncaixinchi.github.io/Blogs/tags/Github/"},{"name":"cheat-sheet","slug":"cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/cheat-sheet/"}]},{"title":"Todo List","date":"2017-02-12T08:42:01.000Z","path":"2017/02/12/Todo-List/","text":"Todo List基于GWAS catalog的基因数据解读Blog计算机英语React教程","tags":[{"name":"blog","slug":"blog","permalink":"https://juncaixinchi.github.io/Blogs/tags/blog/"}]},{"title":"Markdown note","date":"2017-02-12T08:41:46.000Z","path":"2017/02/12/Markdown-note/","text":"Markdown语法摘要基本格式标记+空格+内容标题# 一级标题 # ## 二级标题 ### 三级标题 以此类推，共6级标题，后面的#可加可不加或者一级标题 === 二级标题 --- 列表+ 无序列表 - 无序列表 * 无序列表 1. 有序列表 2. 有序列表 引用引用MarkdownPad2快捷键为ctrl+q图片与链接行内式：链接为：例如：github图片为：![]()例如：![icon](https://juncaixinchi.github.io/juncaixinchi.xyz/favicon.ico)实例：github或者This is [an example][id] reference-style link. [id]: http://example.com/ &quot;Optional Title Here&quot; 实例:This is an example reference-style link.文本样式*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ 注意必须前后包围，且不连空格样式：斜体文本粗体文本代码框` code ` Tab或4个空格+code 分割线*** * * * --- ___ 三个及以上 * 或 - 或 _ ，其间可有空格。样式：转义\\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号","tags":[{"name":"cheat-sheet","slug":"cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/cheat-sheet/"},{"name":"Markdown","slug":"Markdown","permalink":"https://juncaixinchi.github.io/Blogs/tags/Markdown/"}]},{"title":"node install note","date":"2017-02-12T08:39:15.000Z","path":"2017/02/12/node-install-note/","text":"Node安装与npm环境变量配置Node安装进入nodejs官方网站下载软件(nodejs.org)Windows环境下的NodeJS+NPM+Bower安装配置Windows环境下的NodeJS+NPM+Bower安装配置下载完成后，双击默认安装。安装程序会自动添加环境变量Windows环境下的NodeJS+NPM+Bower安装配置检测nodejs是否安装成功。打开cmd命令行 输入 node - v 显示当前版本号Windows环境下的NodeJS+NPM+Bower安装配置检查npm是否安装。由于新版的NodeJS已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行中键入 npm -vWindows环境下的NodeJS+NPM+Bower安装配置npm环境变量配置npm作为一个NodeJS的模块管理，之前我由于没有系统地看资料所以导致安装配置模块的时候走了一大段弯路，所以现在很有必要列出来记录下。我们要先配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立“node_global”及“node_cache”两个文件夹。我们就在cmd中键入两行命令：npm config set prefix “D:\\Program Files\\nodejs\\node_global”和npm config set cache “D:\\Program Files\\nodejs\\node_cache”下面这一步非常关键，我们需要设置系统变量。进入我的电脑→属性→高级→环境变量。在系统变量下新建“NODE_PATH”，输入“D:\\Program Files\\nodejs\\node_global\\node_modules”。安装bower, npm install bower -g; -g表示全局输入 node，require(‘bower’) 测试是否安装成功！","tags":[{"name":"node.js","slug":"node-js","permalink":"https://juncaixinchi.github.io/Blogs/tags/node-js/"}]},{"title":"Hello Hexo","date":"2017-02-12T08:24:56.000Z","path":"2017/02/12/Hello-Hexo/","text":"","tags":[]},{"title":"Hello World","date":"2017-02-12T08:20:13.445Z","path":"2017/02/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","tags":[{"name":"cheat-sheet","slug":"cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/cheat-sheet/"}]}]
[{"title":"Vim-Setting","date":"2017-03-18T12:57:18.000Z","path":"2017/03/18/Vim-Setting/","text":"Vim 是高效的文本编辑器，以下是我整理的日常中经常用到的命令与插件基本编辑命令打开文件filevi file 进入编辑模式i 退出编辑模式，进入命令模式&lt;Esc&gt; 保存并退出:wp 强制（不保存）退去:q! 文件命令将vim窗口分成双栏并打开新文件:vs newfile 在多栏窗口中切换ctrl + w + w 移动命令移动到第一行gg 移动到最后一行G 移动到第7行7gg 插入命令在当前位置生前插入i 在当前行首插入I 在当前行尾插入A 在当前行之后插入一行o 复制、粘贴、删除拷贝当前行或者之后的7行yy y7y 粘贴p 删除当前行或者之后的7行dd d7d 查找命令查找text，按n健查找下一个，按N健查找前一个/text 查找光标处的单词* 设置高亮查找到的内容:set hlsearch 全局替换aaa为bbb:%s/aaa/bbb/g 用//注释第3-5行:3,5 s/^/\\/\\/ /g 撤销和重做撤销（Undo）u 重做（Redo），即撤销的撤销Ctrl + r VIM 代码折叠用缩进表示折叠set foldmethod=indent 全部折叠:set foldlevelstart=0 取消折叠:set foldlevelstart=99 使用空格作为折叠快捷键nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt; 自动加载view，使得上一次折叠的内容可以保存au BufWinLeave * silent mkview au BufWinEnter * silent loadview 安装插件首先要安装Vundle1234567mkdir ~/.vim/bundlemkdir ~/.vim/bundle/Vundle.vimcd ~/.vim/bundle/Vundle.vimgit clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim在.vimrc中配置Vundle，加入以下内容12345678910111213141516171819202122set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; let Vundle manage Vundle, required&quot; use the command below to install the plugins from the command line&quot; vim +PluginInstall +qallPlugin &apos;VundleVim/Vundle.vim&apos;Plugin &apos;vim-syntastic/syntastic&apos;Plugin &apos;Valloric/YouCompleteMe&apos;Plugin &apos;pangloss/vim-javascript&apos;Plugin &apos;mxw/vim-jsx&apos;&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; requiredsyntax on在配置文件的Plugin部分添加插件，如插件vim-jsx的github链接为 https://github.com/mxw/vim-jsx，于是可以写作1Plugin &apos;mxw/vim-jsx&apos;然后运行以下代码安装插件vim +PluginInstall +qall 配置文件.vimrc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; let Vundle manage Vundle, required&quot; use the command below to install the plugins from the command line&quot; vim +PluginInstall +qallPlugin &apos;VundleVim/Vundle.vim&apos;Plugin &apos;vim-syntastic/syntastic&apos;Plugin &apos;Valloric/YouCompleteMe&apos;Plugin &apos;pangloss/vim-javascript&apos;Plugin &apos;mxw/vim-jsx&apos;&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; requiredsyntax on&quot; vim-jsxlet g:jsx_ext_required = 0&quot; syntastic&quot; see more by &apos;:help syntastic&apos;let g:syntastic_javascript_checkers = [&apos;eslint&apos;]let g:syntastic_check_on_w = 0&quot; foldset foldmethod=indentset foldlevelstart=99nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; auto mkview &amp; loadviewau BufWinLeave * silent mkviewau BufWinEnter * silent loadview&quot; indent set tab = 2 blank spaceset ts=2set sw=2set expandtabset smartindentset number","tags":[{"name":"Vim","slug":"Vim","permalink":"https://juncaixinchi.github.io/Blogs/tags/Vim/"},{"name":"Linux","slug":"Linux","permalink":"https://juncaixinchi.github.io/Blogs/tags/Linux/"}]},{"title":"Lifting-State-Up","date":"2017-03-10T13:25:41.000Z","path":"2017/03/10/Lifting-State-Up/","text":"很多情况下，几个组件之间需要共享state。此时就可以利用提升共同state至附组件的方法来处理，参见：Lifting State Up简单而言就是通过在子组件中使用this.props.state代替this.state，将state托管至父组件，进而共享state。其中原来子组件的this.setState要用this.props.setState或者间接的function代替（如下例子中的handleChange），不过其中要注意使用bind(this)方法。以下是一个具体的例子：父组件Calculator.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React from 'react'import TemperatureInput from './TemperatureInput'const BoilingVerdict = (props) =&gt; &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;&#125;const toCelsius = fahrenheit =&gt; (fahrenheit - 32) * 5 / 9const toFahrenheit = celsius =&gt; (celsius * 9 / 5) + 32const tryConvert = (value, convert) =&gt; &#123; const input = parseFloat(value) if (Number.isNaN(input)) &#123; return '' &#125; const output = convert(input) const rounded = Math.round(output * 1000) / 1000 return rounded.toString()&#125;export default class Calculator extends React.Component &#123; constructor(props) &#123; super(props) this.handleCelsiusChange = this.handleCelsiusChange.bind(this) this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this) this.state = &#123; value: '', scale: 'c' &#125; &#125; handleCelsiusChange(value) &#123; this.setState(&#123; scale: 'c', value &#125;) &#125; handleFahrenheitChange(value) &#123; this.setState(&#123; scale: 'f', value &#125;) &#125; render() &#123; const scale = this.state.scale const value = this.state.value const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" value=&#123;celsius&#125; onChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=\"f\" value=&#123;fahrenheit&#125; onChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ) &#125;&#125;子组件TemperatureInput.jsx1234567891011121314151617181920212223242526272829303132import React from 'react'const scaleNames = &#123; c: 'Celsius', f: 'Fahrenheit'&#125;export default class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props) this.handleChange = this.handleChange.bind(this) &#125; handleChange(e) &#123; this.props.onChange(e.target.value) &#125; render() &#123; const value = this.props.value const scale = this.props.scale return ( &lt;fieldset&gt; &lt;legend&gt;Enter value in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ) &#125;&#125;代码可见Github","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://juncaixinchi.github.io/Blogs/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://juncaixinchi.github.io/Blogs/tags/React/"},{"name":"state","slug":"state","permalink":"https://juncaixinchi.github.io/Blogs/tags/state/"}]},{"title":"JSX-Syntax","date":"2017-03-04T11:26:35.000Z","path":"2017/03/04/JSX-Syntax/","text":"JSX 语法JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。可以理解为在JS中编写与XML类似的语言,一种定义带属性树结构（DOM结构）的语法，它的目的不是要在浏览器或者引擎中实现，它的目的是通过各种编译器将这些标记编译成标准的JS语言。Hello World首先是官网的例子helloworld，其中&lt;h1&gt;Hello, world!&lt;/h1&gt;就是使用到了JSX语法。HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=\"vendor-js/react.js\"&gt;&lt;/script&gt; &lt;script src=\"vendor-js/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"vendor-js/babel-core/browser.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在上述JSX语法中要注意的地方：&lt;script&gt; 标签的 type 属性为 text/babel，这是React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是在页面中直接使用 JSX 的地方，都要加上 type=&quot;text/babel&quot;。一共用了三个库： react.js 、react-dom.js 和 browser.min.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能， browser.min.js的作用是将 JSX 语法转为 JavaScript 语法。ReactDOM.render 是 React 的最基本方法，将模板转为HTML语言，并插入指定的 DOM 节点。将 JSX 语法转为 JavaScript 语法，这一步很消耗时间。现在前端项目，都会使用前端工程化，不会直接在html页面中直接写js代码，写好的js代码都会使用工具进行编译压缩等。这样的话，JSX也会通过编译直接转化成js语法，让浏览器直接使用。JSX的特点类XML语法容易接受，结构清晰增强JS语义抽象程度高，屏蔽DOM操作，跨平台代码模块化JSX基本语法规则JSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，即：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example'));JavaScript表达式基础语法用一对大括号 { } 包起来的JavaScript表达式可以作为标签的子结点（children），也可以是属性值123456789// 以下语句等价&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/MyComponent&gt;// JavaScript 表达式作为属性值React.render( &lt;div className=&#123;2 &gt; 1 ? 'class-a' : 'class-b'&#125;&gt;content&lt;/div&gt;, document.body);条件判断的写法因为 JSX 只是函数调用和对象创建的语法糖，在 { } 中不能 if-else 语句，不过可以采用三元操作表达式123456var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name ？ this.props.name : \"World\"&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name=\"xiaowang\" /&gt;, document.body);可以使用比较运算符“ &amp;&amp; ” 和 “ || ”来替代“ if ”“&amp;&amp;” ：如果左边的值为真，才返回右边的表达式，不过要注意&amp;&amp;之前的需要是一个boolean值1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt;“||” ：如果左边的值为真，则直接返回左边的值，否则返回右边的值12345var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name || \"World\"&#125;&lt;/div&gt;; &#125;&#125;);Children in JSX在JSX表达式中包括开标签和闭标签，这俩个标签之间的内容被定义为一个特殊的prop，即props.childrenString Literals as Children开标签和闭标签的内容或者props.children的值可以是一个string，这与HTML的语法相同12&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt;JSX elements as the ChildrenChildren也可以是一个JSX element，以下是一个“纯组件”的例子1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt;JavaScript Expressions as Childrenchildren也可以是JavaScript表达式，需要用{}包起来，以下是渲染一个任意行数的HTML list的例子123456789101112function Item(props) &#123; return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;function TodoList() &#123; const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt; );&#125;Functions as Children一般情况下，在JSX中的插入的JavaScript表达式会最终表现为string、React element或者这些内容形成的list。但是props.children实际上可以传递任何数据，不需要一定是React可以render的内容。例如，可以自定义一个组件，其children是一个函数，最终函数的callback作为props.children12345678910111213141516// Calls the children callback numTimes to produce a repeated componentfunction Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125;所以说Children传给组件的可以是任意内容，只要组件能够在render前，将children转化为React能够理解的内容即可。注释render函数内的注释需要写在花括号中，实例如下：1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &#123;/*注释...*/&#125; &lt;/div&gt;, document.getElementById('example'));JSX 陷阱style属性在React中写行内样式时，要使用`style={{}}`的方式，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。即`margin-top`要写成`marginTop`。骆驼式命名法就是当变量名或函式名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName 等，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。123456React.render( &lt;div style=&#123;&#123;color:'red'&#125;&#125;&gt; xxxxx &lt;/div&gt;, document.body);HTML转义React默认会进行HTML的转义，避免XSS攻击123456var content='&lt;strong&gt;content&lt;/strong&gt;';React.render( &lt;div&gt;&#123;content&#125;&lt;/div&gt;, document.body);//结果页面直接输出内容了\"&lt;strong&gt;content&lt;/strong&gt;\"自定义HTML属性如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。1&lt;div data-custom-attribute=\"foo\" /&gt;组件类只能包含一个顶层标签123//var myDivElement =&lt;h1&gt;你好&lt;/h1&gt;&lt;h1&gt;hello&lt;/h1&gt;;//上述写法是会报错的，要写成只有一个顶层标签：var myDivElement =&lt;div&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/div&gt;;Boolean 属性省略一个属性的值会导致JSX把它当做 true。要传值 false必须使用属性表达式。这常出现于使用HTML表单元素，含有属性如disabled, required, checked 和 readOnly。1234567// 在JSX中，对于禁用按钮这二者是相同的。&lt;input type=\"button\" disabled /&gt;;&lt;input type=\"button\" disabled=&#123;true&#125; /&gt;;// 在JSX中，对于不禁用按钮这二者是相同的。&lt;input type=\"button\" /&gt;;&lt;input type=\"button\" disabled=&#123;false&#125; /&gt;;React组件基础用法使用JSX来将代码封装成React组件，然后像插入普通 HTML 标签一样，在其他地方插入这个组件。使用React.createClass用于生成一个组件。123456789var MyComponent=React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello world!&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example'));上面代码中，变量 MyComponent就是一个组件类。模板插入时，会自动生成 MyComponent 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。HTML 标签 vs. React 组件React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。渲染HTML标签，声明变量采用首字母小写123//要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。var myDivElement = &lt;div className=\"foo\" /&gt;;React.render(myDivElement, document.getElementById('example'));渲染React组件，声明变量采用首字母大写1234//要渲染 React 组件，只需创建一个大写字母开头的本地变量。var MyComponent = React.createClass(&#123;/*...*/&#125;);var myElement = &lt;MyComponent /&gt;;React.render(myElement, document.getElementById('example'));动态组件1234567891011121314151617181920212223242526var MyComponent=React.createClass(&#123; getInitialState: function() &#123; return &#123;clickNum: 0&#125;; &#125;, handleClick:function()&#123; var num=this.state.clickNum; num++; this.setState(&#123;clickNum:num&#125;); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;h1 onClick=&#123;this.handleClick&#125;&gt;Hello &#123;this.props.name&#125;!&lt;/h1&gt; &lt;h2 style=&#123;&#123;color:'red'&#125;&#125;&gt;点击&#123;this.props.name&#125;次数：&#123;this.state.clickNum&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;div&gt; &lt;MyComponent name=\"张三\" /&gt; &lt;hr/&gt; &lt;MyComponent name=\"李四\" /&gt; &lt;/div&gt;, document.getElementById('example'));上面代码中定义的MyComponent组件包含属性，状态和事件，是一个简单的比较完整的组件。使用props通过父组件进行传递值使用state定义组件自己的状态组件支持的大部分的DOM操作事件属性props的注意要点class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。+this.props.children 不要children作为把对象的属性名。因为this.props.children获取的该标签下的所有子标签。this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。官方建议使用React.Children.map来遍历子节点，而不用担心数据类型。状态state的注意要点组件免不了要与用户互动，React 将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI。getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。由于 this.props 和 this.state 的简单的区分方法：this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://juncaixinchi.github.io/Blogs/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://juncaixinchi.github.io/Blogs/tags/React/"},{"name":"JSX","slug":"JSX","permalink":"https://juncaixinchi.github.io/Blogs/tags/JSX/"}]},{"title":"ECMAScript-6-note","date":"2017-03-02T12:38:44.000Z","path":"2017/03/02/ECMAScript-6-note/","text":"学习ES6的笔记ECMAScript 6.0 是JavaScript语言的下一代标准，已经在2015年6月正式发布主要学习了阮一峰老师的ECMAScript 6 入门ES6转码器Babel转码器Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，可通过npm安装。同时Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码Traceur转码器Traceur转码器由Google公司开发，也可以将ES6代码转为ES5代码，也可通过在线编译器转换代码let和const命令1. let命令ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效for循环的计数器，就很合适使用let命令12for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);let不存在变量提升，变量应该在声明语句之后才可以使用，且不允许在相同作用域内，重复声明同一个变量12345678910111213141516171819// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）12345678var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125;typeof x; // ReferenceErrorlet x;2.块级作用域let实际上为JavaScript新增了块级作用域，{}内部即为一个块级作用域1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;ES6 引入了块级作用域，明确允许在块级作用域之中声明函数1234'use strict';if (true) &#123; function f() &#123;&#125;&#125;浏览器环境并一定完全兼容，故在块级作用域内声明函数时，建议用函数表达式，而不是函数声明语句1234567// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125;3.const命令const声明一个只读的常量。一旦声明变量，就必须立即初始化，只在声明所在的块级作用域内有效12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only如果真的想将对象冻结，应该使用Object.freeze方法12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;4.顶层对象的属性var命令和function命令声明的全局变量，依旧是顶层对象的属性let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined5.global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;;变量的解构赋值","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://juncaixinchi.github.io/Blogs/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://juncaixinchi.github.io/Blogs/tags/ES6/"}]},{"title":"Javascript-note","date":"2017-02-22T13:57:57.000Z","path":"2017/02/22/Javascript-note/","text":"学习javascript的笔记主要学习了JavaScript教程字符串多行字符串这是一个 多行 字符串;toUpperCase(),toLowerCase() 把一个字符串全部变为大写或小写123var s = 'Hello';s.toUpperCase(); // 返回'HELLO's.toLowerCase(); // 返回'hello'indexOf()搜索指定字符串出现的位置123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1substring()返回指定索引区间的子串123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world'数组通过Array.length获取数组长度，给length赋一个新的值或索引赋值时索引超过了范围，会导致Array大小的变化123456var arr = [1, 2, 3.14];arr.length; // 3arr.length = 4;arr; // arr变为[1, 2, 3.14, undefined]arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x']通过indexOf()来搜索Array中一个指定的元素的位置123var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(30); // 元素30没有找到，返回-1通过slice()截取Array的部分元素，然后返回一个新的Array123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉,unshift()往Array的头部添加若干元素，shift()则把Array的第一个元素删掉123456789101112var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.unshift('A', 'B'); // 返回Array新的长度: 5arr; // ['A', 'B', 1, 2, 'A']arr.shift(); // 'A'arr; // ['B', 1, 2, 'A']arr = [];arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr.shift(); // 空数组继续shift不会报错，而是返回undefinedsort(), reverse()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认把所有元素先转换为String，再根据ASCII码进行排序12345var arr = ['B', 'C', 'A', 'b'];arr.sort();arr; // ['A', 'B', 'C', 'b']arr.reverse(); arr; //['b', C', 'B', 'A']splice()方法可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：123var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]arr; // ['A', 'B', 'C']join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：123var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3'arr.join(''); // 'ABC123'如果数组的某个元素又是一个Array，则可以形成多维数组12var arr = [[1, 2, 3], [400, 500, 600], '-'];arr[1][1]; //500对象JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来123456789101112var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红'xiaoming.age; // undefined要检测xiaoming是否拥有某一属性，可以用in操作符。因为toString定义在object对象中，所以xiaoming继承了toString属性；可以用hasOwnProperty()方法判断一个属性是否是xiaoming自身拥有的，而不是继承得到的。123456var xiaoming = &#123; name: '小明'&#125;;'toString' in xiaoming; // truexiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false条件判断使用if () { ... } else { ... }来进行条件判断，else if通常连写在一起，以增加可读性。12345678var age = 3;if (age &gt;= 18) &#123; console.log('adult');&#125; else if (age &gt;= 6) &#123; console.log('teenager');&#125; else &#123; console.log('kid');&#125;循环for循环最常用的地方是利用索引来遍历数组123456var arr = ['Apple', 'Google', 'Microsoft'];var i, x;for (i=0; i&lt;arr.length; i++) &#123; x = arr[i]; console.log(x);&#125;for循环的3个条件都是可以省略的，但必须使用break语句退出循环，否则就是死循环1234567var x = 0;for (;;) &#123; // 将无限循环下去 if (x &gt; 100) &#123; break; // 通过if判断来退出循环 &#125; x ++;&#125;for ... in循环可以把一个对象的所有属性依次循环出来12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125;for ... in循环可以直接循环出Array的索引，但得到索引的是String而不是Number12345var a = ['A', 'B', 'C', 1, 2, 3];for (var i in a) &#123; console.log(i) console.log(a[i]); &#125;while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500do { ... } while()循环，它和while循环的唯一区别在于前者是在每次循环完成的时候判断条件，所以至少会执行一次循环12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100Map和SetMap是一组键值对的结构，具有极快的查找速度，Map具有以下方法：12345678var M = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefinedSet是一组key的集合，不能重复，重复元素在Set中自动被过滤123456var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125;s.add(4); // Set &#123;1, 2, 3, \"3\", 4&#125;s.delete(2); // Set &#123;1, 3, \"3\", 4&#125;s.size; //4s.has(3); // trueiterablefor ... of循环来遍历Array、Map和Set123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '&lt;=&gt;' + x[1]);&#125;iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数，以下是Array的例子1234567var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(\"element: \" + element + \"; index: \" + index + \"; array: \" + array);&#125;);Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(\"element: \" + element + \"; sameElement: \" + sameElement + \"; set: \" + set);&#125;);Map的回调函数参数依次为value、key和map本身1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(\"value: \" + value + \"; key: \" + key + \"; map: \" + map);&#125;);函数定义和调用12345678// 一般定义function abs(x) &#123; return x&gt;0 ? x : -x;&#125;// 匿名函数定义var abs = function (x) &#123; return x&gt;0 ? x : -x;&#125;;利用arguments获取所有传入参数12345678910function abs() &#123; if (arguments.length === 0) &#123; return 0; &#125; if (typeof x !== 'number') &#123; throw 'Not a number'; &#125; var x = arguments[0]; return x &gt;= 0 ? x : -x;&#125;使用rest来获取任意个参数，需写在最后面，前面加...1234567891011121314function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;// sum()函数，接收任意个参数并返回它们的和function sum(x, ...rest) &#123; let tmp = 0; if(x) tmp += x; for(let i of rest)&#123; tmp += i; &#125; return tmp;&#125;## 变量作用域var定义变量，该变量的作用域为整个函数体。不在任何函数内定义的变量就具有全局作用域，被绑定到全局对象window的一个属性123456789'use strict';var course = 'Learn JavaScript';console.log(course); // 'Learn JavaScript'console.log(window.course); // 'Learn JavaScript'function foo() &#123; console.log('you foo');&#125;foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用ES6引入了新的关键字let，用let替代var可以申明一个块级作用域(for循环等)的变量1234567function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; return sum;&#125;ES6标准引入了新的具有块级作用域的关键字const来定义常量123const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14方法在一个对象中绑定函数，称为这个对象的方法，在一个方法内部，this是一个特殊变量，它始终指向当前对象123456789var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age(); //2017年则是27apply()可以指定函数的this的指向1234567891011function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空call()方法与apply()类似apply()把参数打包成Array再传入；call()把参数按顺序传入。12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5利用apply()动态改变函数的行为，如通过用我们自己的函数替换掉默认的parseInt()的方法统计代码一共调用了多少次parseInt()1234567891011121314var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;;// 测试:parseInt('10');parseInt('20');for(let x=0;x&lt;10;x++)&#123; parseInt('30');&#125;count; // 12高阶函数map()方法将array内的每一个元素一次处理1234567function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3];arr.map(pow); // [1, 4, 9]arr.map(String);//[\"1\",\"2\",\"3\"]reduce()方法把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算1234567891011[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)// 求和var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25//将字符串转化为Number的函数function string2int(s) &#123; return s.split(\"\").map(function(x)&#123;return x-0&#125;).reduce(function(x,y)&#123;return x*10+y&#125;);&#125;string2int(\"23434\");//23434filter()方法把传入的函数依次作用于array的每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素123456789101112131415161718192021222324// 删掉Array中的空字符串var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);arr; // ['A', 'B', 'C']// 回调函数var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;);// 去除array中的重复元素varr,arr = ['1', '1', '2', '3', '2', '4', '5', '1'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);//[\"1\", \"2\", \"3\", \"4\", \"5\"]sort()方法默认把所有元素先转换为String再以ASCII排序，直接使用对数字排序会有大Bug，可通过自定义方式解决问题。sort()方法会直接对Array进行修改，它返回的结果仍是当前Array12345678910111213// 升序排列var arr = [10, 20, 1, 2];a2 = arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20]a2 = arr; // true闭包闭包就是能够读取其他函数内部变量的函数，由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁12345678910111213function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125;; function f2()&#123; console.log(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000// 函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除箭头函数ES6标准新增了一种新的函数：Arrow Function（箭头函数）12345x =&gt; x * x// 相当于function (x) &#123; return x * x;&#125;箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25generatorgenerator（生成器）是ES6标准引入的新的数据类型，使用function*定义。一个generator看上去像一个函数，但可以返回多次12345678910111213141516171819//斐波那契数列function* fib(min,max) &#123; var t, a = 0, b = 1, n = 1; while (n &lt;= max) &#123; if(n &gt;= min)&#123; yield a; &#125; t = a + b; a = b; b = t; n ++; &#125; return a;&#125;for (let x of fib(4,5)) &#123; console.log(x); // 依次输出2, 3&#125;对象类型转换和判断需要注意的问题：用parseInt()或parseFloat()来转换任意类型到number；用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；typeof操作符可以判断出number、boolean、string、function和undefined；判断Array要使用Array.isArray(arr)；判断null请使用myVar === null；判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;；函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。123//number的toString()要特殊处理123..toString(); // '123', 注意是两个点！(123).toString(); // '123'Date 对象在JavaScript中，Date对象用来表示日期和时间，使用Date()获取系统时间；123456789101112131415var now = new Date();now; // Mon Feb 27 2017 22:24:10 GMT+0800 (中国标准时间)now.getFullYear(); // 2017, 年份now.getMonth(); // 1, 月份，注意月份范围是0~11，1表示二月now.getDate(); // 27, 表示27号now.getDay(); // 1, 表示星期一now.getHours(); // 22, 24小时制now.getMinutes(); // 24, 分钟now.getSeconds(); // 10, 秒now.getMilliseconds(); // 264, 毫秒数now.getTime(); // 1488205450264, 以number形式表示的时间戳var d = new Date(1970, 0, 1, 7, 59, 59, 999);d; // Thu Jan 01 1970 07:59:59 GMT+0800 (中国标准时间)d.getTime(); -1;RegExp正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的1234// 匹配正常Email地址的表达式var MailCheck = /^[0-9a-zA-Z\\_\\.]+@[0-9a-zA-Z\\_]+\\.[0-9a-zA-Z\\_]+/;MailCheck.exec('juncaixinchi111#gmail.com'); // nullMailCheck.exec('juncaixinchi111@gmail.com'); // ['juncaixinchi111@gmail.com']JSONJSON是JavaScript Object Notation的缩写，它是一种数据交换格式使用JSON.stringify()把对象序列化成JSON格式的字符串：12345678910var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']&#125;;JSON.stringify(xiaoming); // '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'按缩进输出：12345678910111213141516JSON.stringify(xiaoming, null, ' ');// 结果&#123; \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]&#125;给对象定义一个toJSON()的方法，直接返回JSON应该序列化的数据1234567891011121314151617var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming); // '&#123;\"Name\":\"小明\",\"Age\":14&#125;'使用JSON.parse()反序列化123456789JSON.parse('&#123;\"name\":\"小明\",\"age\":14&#125;'); // Object &#123;name: '小明', age: 14&#125;// 接收一个函数，用来转换解析出的属性JSON.parse('&#123;\"name\":\"小明\",\"age\":14&#125;', function (key, value) &#123; // 把number * 2: if (key === 'name') &#123; return value + '同学'; &#125; return value;&#125;); // Object &#123;name: '小明同学', age: 14&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://juncaixinchi.github.io/Blogs/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://juncaixinchi.github.io/Blogs/tags/ES6/"}]},{"title":"Simple-Canvas-Game","date":"2017-02-18T15:10:08.000Z","path":"2017/02/18/Simple-Canvas-Game/","text":"利用HTML5 Canvas制作小游戏的简单教程，详见 simple_canvas_game1. 创建一个Canvas对象123456// Create the canvasvar canvas = document.createElement(\"canvas\");var ctx = canvas.getContext(\"2d\");canvas.width = 512;canvas.height = 480;document.body.appendChild(canvas);我们首先要做的是创建一个canvas对象。可以用JavaScript或HTML来做，都非常简单。此处我用的是JS。当创建了canvas之后，我们就可以获取它的上下文对象（context）、设置尺寸，并且把它加到当前文档中。2. 载入图片1234567// Background imagevar bgReady = false;var bgImage = new Image();bgImage.onload = function () &#123; bgReady = true;&#125;;bgImage.src = \"images/background.png\";游戏需要图像，所以让我们载入一些图片吧。我想尽量简单化，所以只用了Image对象来做，当然，还可以将载入图像的功能封装成一个类或别的任何形式。代码中的bgReady用来标识图片是否已完全载入，只有当图片载入完成后，我们才能使用它，如果在载入完成前就对其进行绘制或渲染，JS将会报一个DOM error的错误。我们会用到三张图片（背景、英雄、怪物），每张图片都需要这样处理。3. 定义游戏要使用的对象1234567891011// Game objectsvar hero = &#123; speed: 256, // movement in pixels per second x: 0, y: 0&#125;;var monster = &#123; x: 0, y: 0&#125;;var monstersCaught = 0;定义一些变量，稍后会用到。hero对象的speed属性表示英雄的移动速度（像素/秒）；monster对象不会移动，所以仅仅具有一对坐标；monstersCaught表示玩家抓住的怪物数量。4. 处理玩家输入12345678// Handle keyboard controlsvar keysDown = &#123;&#125;;addEventListener(\"keydown\", function (e) &#123; keysDown[e.keyCode] = true;&#125;, false);addEventListener(\"keyup\", function (e) &#123; delete keysDown[e.keyCode];&#125;, false);现在进行输入的处理。（对具有web开发背景的人来说，这是目前为止第一个具有挑战性的部分）对一般的网页来说，当用户开始输入时，可能需要马上开始播放动画或请求数据。但在这里，我们想让游戏逻辑在一个单独的地方对游戏中发生的事情进行处理。为此我们需要将用户输入保存下来以备稍后处理，而不是立即处理。我们通过简单地将事件对应的键编码（keyCode）保存在keysDown变量中来实现。如果该变量中具有某个键编码，就表示用户目前正按下这个键。简单吧！5. 新游戏123456789// Reset the game when the player catches a monstervar reset = function () &#123; hero.x = canvas.width / 2; hero.y = canvas.height / 2; // Throw the monster somewhere on the screen randomly monster.x = 32 + (Math.random() * (canvas.width - 64)); monster.y = 32 + (Math.random() * (canvas.height - 64));&#125;;通过调用reset函数来开始新游戏。该函数将英雄（即玩家角色）放到屏幕中间，然后随机选择一个位置来安置怪物。6. 更新对象1234567891011121314151617181920212223242526// Update game objectsvar update = function (modifier) &#123; if (38 in keysDown) &#123; // Player holding up hero.y -= hero.speed * modifier; &#125; if (40 in keysDown) &#123; // Player holding down hero.y += hero.speed * modifier; &#125; if (37 in keysDown) &#123; // Player holding left hero.x -= hero.speed * modifier; &#125; if (39 in keysDown) &#123; // Player holding right hero.x += hero.speed * modifier; &#125; // Are they touching? if ( hero.x &lt;= (monster.x + 32) &amp;&amp; monster.x &lt;= (hero.x + 32) &amp;&amp; hero.y &lt;= (monster.y + 32) &amp;&amp; monster.y &lt;= (hero.y + 32) ) &#123; ++monstersCaught; reset(); &#125;&#125;;这是update函数，游戏每隔一定时间会调用它一次。它所做的第一件事情是检查用户是否按下了上下左右四个箭头键。如果是，就将我们的英雄向相应的方向移动。update有一个modifier参数，这看起来好像有点奇怪。你会在游戏的主函数即main函数中看到它，不过我在这儿先解释一下。modifier参数是一个从1开始的与时间相关的数。如果间隔刚好为1秒时，它的值就会为1，英雄移动的距离即为256像素（英雄的速度为256像素/秒）；而如果间隔是0.5秒，它的值就为0.5，即英雄移动的距离为其速度的一半，以此类推。通常update函数调用的间隔很短，所以modifier的值很小，但用这种方式能够确保不管代码执行的速度怎么样，英雄的移动速度都是相同的。我们已经实现了根据用户的输入来移动英雄，但我们还可以在移动英雄时对其进行检查，以确定是否有其他事件发生。例如：英雄是否与怪物发生了碰撞——当英雄与怪物发生碰撞时，我们为玩家进行计分（monstersCaught加1）并重置游戏（调用reset函数）。7. 渲染对象123456789101112131415161718192021// Draw everythingvar render = function () &#123; if (bgReady) &#123; ctx.drawImage(bgImage, 0, 0); &#125; if (heroReady) &#123; ctx.drawImage(heroImage, hero.x, hero.y); &#125; if (monsterReady) &#123; ctx.drawImage(monsterImage, monster.x, monster.y); &#125; // Score ctx.fillStyle = \"rgb(250, 250, 250)\"; ctx.font = \"24px Helvetica\"; ctx.textAlign = \"left\"; ctx.textBaseline = \"top\"; ctx.fillText(\"Goblins caught: \" + monstersCaught, 32, 32);&#125;;当你能够看到你的行动时游戏才会变得更有趣，所以让我们在屏幕上绘制吧。首先我们将背景图片绘制到canvas，然后是英雄和怪物。注意顺序很重要，因为任何位于表层的图片都会将其下面的像素覆盖掉。接下来是文字，这有些不同，我们调用fillText函数显示玩家的分数。因为不需要复杂的动画或者对文字进行移动，所以只是绘制一下就ok了。8. 游戏主循环12345678910// The main game loopvar main = function () &#123; var now = Date.now(); var delta = now - then; update(delta / 1000); render(); then = now;&#125;;游戏的主循环用来控制游戏流程。首先我们要获得当前的时间，这样我们才能计算时间差（自上次循环以来经过的时间）。然后计算modifier的值并交给update（需要将delta除以1000以将其转换为毫秒）。最后调用render并更新记录的时间。更多关于游戏循环的内容见“Onslaught! Arena Case Study”。9. 开始游戏吧1234// Let's play this game!reset();var then = Date.now();setInterval(main, 1); // Execute as fast as possible快完成了，这是最后一段代码。首先调用reset来开始新游戏。（还记得吗，这会将英雄置中并随机安放怪物）。然后将起始时间保存到变量then中并启动游戏的主循环。OK！（但愿）你现在已经理解了在HTML5 Canvas中用JS来开发游戏的基础知识了。建议最好是能够自己亲自试一把！","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://juncaixinchi.github.io/Blogs/tags/Canvas/"},{"name":"Game","slug":"Game","permalink":"https://juncaixinchi.github.io/Blogs/tags/Game/"},{"name":"Demo","slug":"Demo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Demo/"}]},{"title":"Git_note","date":"2017-02-14T11:36:07.000Z","path":"2017/02/14/Git-note/","text":"Git note学习Git的笔记，完整文档见Git-scmGit 配置获取升级$ git clone git://git.kernel.org/pub/scm/git/git.git 添加用户信息，并查看配置文件$ git config --global user.name &quot;juncaixinchi&quot; $ git config --global user.email &quot;juncaixinchi111@gmail.com&quot; $ less ~/.gitconfig 获取帮助$ git help &lt;verb&gt; $ git &lt;verb&gt; --help $ man git-&lt;verb&gt; 生成ssh keys，在Github-keys添加即可$ ssh-keygen -t rsa -b 4096 -C &quot;juncaixinchi111@gmail.com&quot; $ clip &lt; ~/.ssh/id_rsa.pub Git 基础在现有目录中初始化仓库$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。$ git add * $ git commit -m &apos;initial project version&apos; 在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，应该开始跟踪这些文件并提交。克隆现有的仓库克隆blog-generater至当前目录，分别使用HTTPS协议、SSH协议、本地协议$ git clone https://github.com/juncaixinchi/blog-generater.git $ git clone git@github.com:juncaixinchi/blog-generater.git $ git clone /opt/git/project.git 记录每次更新到仓库$ git add README 使用命令 git add 开始跟踪跟踪 README 文件$ git status $ git status -s 检查当前文件状态，加-s为简略信息忽略文件创建一个名为 .gitignore 的文件，列出要忽略的文件模式，文件 .gitignore 的格式规范如下：所有空行或者以 ＃ 开头的行都会被 Git 忽略。要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。# no .a files *.a 匹配模式可以以（/）开头防止递归。# only ignore the TODO file in the current directory, not subdir/TODO /TODO 匹配模式可以以（/）结尾指定目录。# ignore all files in the build/ directory build/ 可以使用标准的 glob 模式匹配。# ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 提交更新commit命令会提交更新，-m参数可添加提交备注，或者随机生成备注 O__O$ git commit -m &quot;update&quot; $ git commit -m &quot;`curl -s http://whatthecommit.com/index.txt`&quot; 给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 add 步骤$ git commit -a -m &apos;update without git add&apos; 不过正式的提交还是应该避免-m 添加备注，而是详细的添加移除文件或移动文件使用 rm 命令将文件从已跟踪文件清单中移除，并连带从工作目录中删除指定的文件，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f$ git rm file_to_remove.md $ git mv file_from file_to 查看提交历史查看所有log$ git log 显示最近两次提交的差异$ git log -p -2 显示每次提交的简略的统计信息$ git log --stat 以pretty的方式显示提交历史$ git log --pretty=oneline 添加了一些ASCII字符串来形象地展示你的分支、合并历史：$ git log --pretty=format:&quot;%h %s&quot; --graph 只显示作者L在2周内提交的近5条记录$ git log --author L --since=2.weeks -5 撤消操作尝试重新提交,第二次提交将代替第一次提交的结果$ git commit -m &apos;initial commit&apos; $ git add forgotten_file $ git commit --amend 取消暂存的文件file_to_cancle.txt(git add 的相反操作)$ git reset HEAD file_to_cancle.txt 撤消对文件的修改，恢复文件file_to_restore.txt到上次提交时候的状态$ git checkout -- file_to_restore.txt 远程仓库的使用查看远程仓库$ git remote -v $ git remote show 添加远程仓库，默认为 origin$ git remote add &lt;shortname&gt; &lt;url&gt; $ git remote add pd https://github.com/juncaixinchi/blog-generater.git 从远程仓库中抓取，默认从origin抓取，也可自定义$ git fetch $ git fetch https://github.com/juncaixinchi/blog-generater.git $ git fetch origin master:tmp git fetch不会自动merge，需再merge$ git fetch origin master:tmp $ git diff tmp $ git merge tmp 直接从远程获取最新版本并merge到本地$ git pull origin master 使用 git push (remote) (branch)推送到远程仓库，默认推送到origin/master, 也可自定义远程仓库及分支（如serverfix）$ git push $ git push https://github.com/juncaixinchi/blog-generater.git $ git push origin serverfix $ git push origin serverfix:awesomebranch 设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支$ git checkout --track origin/serverfix 远程仓库的移除和重命名$ git remote rm paul $ git remote rename pb paul 删除远程分支serverfix$ git push origin --delete serverfix 打标签列出已有标签$ git tag 创建一个附注标签，指定提交的校验和（或部分校验和）则可后期打标签$ git tag -a v1.4 -m &apos;my version 1.4&apos; $ git tag -a v0.0 -m &quot;origin version&quot; c76e548 共享标签$ git push origin v1.5 设置别名通过 config 为命令设置别名，外部程序的命令则要加!，使用cmu直接add 及 commit$ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.st status $ git config --global alias.last &apos;log -1 HEAD&apos; $ git config --global alias.hexo &apos;!hexo g -delpoy&apos; $ git config --global alias.cmu &apos;commit -a -m &quot;update&quot;&apos; $ git config --global alias.logbr &apos;log --oneline --decorate --graph --all -20&apos; Git 分支分支的新建和合并创建分支testing，分支切换为testing，然后commit内容将在test分支进行$ git branch testing $ git checkout testing 或者在过去某个版本，如593015f,建立分支testing$ git log --oneline --decorate --graph --all $ git checkout 593015f $ git checkout -b testing 使用 log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 –decorate。$ git log --oneline --decorate $ git log --oneline --decorate --graph --all 使用 merge 来合并分支$ git merger testing 如果 master 和 testing 分支都各有提交新版本，则无法自动合并，会出现如下错误，需要手动编辑冲突的文件，然后再 commit，Auto Merge Failed; Fix Conflicts and Then Commit the Result 例如冲突的文件内容为：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; testing:index.html 这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置）在这个区段的上半部分（======= 的上半部分），而 testing 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，必须选择使用由 ======= 分割的两部分中的一个，或者也可以自行合并这些内容。 例如，通过把这段内容换成下面的样子来解决冲突：&lt;div id=&quot;footer&quot;&gt; please contact us at email.support@github.com &lt;/div&gt; 另外也可以使用图形化工具来解决冲突$ git mergetool 合并完成后删除分支testing$ git branch -d testing 分支的管理显示分支列表$ git branch 查看每一个分支的最后一次提交$ git branch -v 查看已经合并或尚未合并到当前分支的分支$ git branch --merged $ git branch --no-merged 删除和强制删除分支$ git branch -d testing $ git branch -D testing 分支整合之变基使用 rebase 命令将提交到某一分支 testing 上的所有修改都移至另一分支 master 上，然后回到 master 分支，进行一次快进合并。$ git checkout testing $ git rebase master $ git checkout master $ git merge testing 直接将特性分支（testing）变基到目标分支（即 master）上$ git rebase master testing 对两个分支进行变基时，将 client 中的修改合并到主分支并发布，但暂时并不合并 server 中的修改$ git rebase --onto master server client 变基的风险：不要对在仓库外有副本的分支执行变基Git工具子模块将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。$ git submodule add git@github.com:juncaixinchi/hexo-theme-next.git themes/next $ git submodule init $ git submodule update $ git submodule update themes/next 在开始克隆含有子模块的仓库时，可添加–recursive，直接递归添加所有子模块$ git clone --recursive https://github.com/juncaixinchi/blog-generater.git 让 Git 在推送到主项目前检查所有子模块是否已推送$ git push --recurse-submodules=check 让 Git 自动进入到子模块中，然后在推送主项目前推送了它$ git push --recurse-submodules=on-demand 遍历子模块运行命令$ git submodule foreach &apos;git push&apos; 调试通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。开始二分查找，并设置当前版本为有问题状态$ git bisect start $ git bisect bad 设定没有问题的版本，然后依次检测个版本，设定 bad or good ，直到找到问题版本$ git bisect good v1.0 完成后，重置 HEAD 指针到最开始的位置$ git bisect reset 标注任何文件的行，指出文件的每一行的最后的变更的提交及谁是那一个提交的作者，通过-L来限定行数$ git blame $ git blame -L 12,22 file_to_check 在源代码中，甚至是你项目的老版本中的任意文件中查找任何字符串或者正则表达式$ git grep 维护项目balabala…","tags":[{"name":"Git","slug":"Git","permalink":"https://juncaixinchi.github.io/Blogs/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://juncaixinchi.github.io/Blogs/tags/Github/"}]},{"title":"基于Hexo+Next+GitHub搭建个人博客","date":"2017-02-14T08:24:56.000Z","path":"2017/02/14/Blog-driven-by-hexo/","text":"基于Hexo+Next+GitHub搭建个人博客简介Hexo是依赖于node.js的个人博客生成引擎，可以把基于Markdown的文件生成博客页面，所以整个项目分为两部分：网页生成安装配置Hexo及其主题Next，撰写整理博客文档，生成静态页面 blog-generater网页部署生成的网页存在于public文件夹内，将其部署到Github Pages或其他服务器即可 Blogs安装和配置首先要有node.js，然后用npm安装hexo$ npm install -g hexo-cli 切换到博客的位置$ cd ~/Github/ 生成新的博客文件夹，这会需要一段时间$ hexo init blog $ cd blog 开启服务器，默认为 http://127.0.0.1:4000/ 可在本地查看$ hexo server 生成新的文章，这里”Hello Hexo”只是标题，然后可以编辑Hello-Hexo.md撰写博客$ vi ./source/_posts/Hello-Hexo.md 生成静态文件，以便部署到Github Pages，详细配置见下文$ hexo generate $ hexo deploy 或者合并$ hexo generate --deploy 安装压缩页面的插件$ npm install hexo-all-minifier --save 自动生成静态页面和部署安装 hexo-deployer-git.$ npm install hexo-deployer-openshift --save 编辑配置文件，需在github先新建repository：Blogsdeploy: type: git repo: git@github.com:juncaixinchi/Blogs.git branch: master 生成静态文件和自动部署hexo generate --deploy 配置与添加主题在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。设置网站路径很关键，否则上传至GitHub不能正确加载css和jsurl: https://juncaixinchi.github.io/Blogs/ root: /Blogs/ 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans 设置 头像将avatar.png放置在 source/images/ 目录下，站点配置文件新增字段 avatar，配置为：avatar: /images/avatar.png 安装主题因为添加主题next，在上传GitHub Pages的时候遇到了以下问题：Page build failed: Missing submodule 发现是submodule没有配置好，删除原来的 themes/next/ 文件使用以下代码重新配置$ git submodule add git@github.com:juncaixinchi/hexo-theme-next.git themes/next $ git submodule init $ git submodule update 选择主题SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。#scheme: Muse #scheme: Mist scheme: Pisces 添加标签云页面新建一个页面，命名为 tags 。命令如下：hexo new page &quot;tags&quot; 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云，如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：title: All tags date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 在菜单中添加链接。编辑主题的 _config.yml ，添加 tags 到 menu 中，如下:menu: home: / archives: /archives tags: /tags 404页面设置设置腾讯的404公益页面，在source/下添加404.html12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"all\" /&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://juncaixinchi.github.io/Blogs/\" homePageName=\"回到我的主页\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;但是该页面使用http获取js，且其中嵌入的各种链接都是http，而Github要求全部为https。故修改代码（见下面）。其中search_children.js主要提取了data.js及page.js两个文件，前者是寻找儿童的数据，在Github中没问题；后者中默认都是用http加载的js和css，所以不能直接用，故改为https方式获取js与css，直接加入404.html页面，内容详见：404.html然后生成文件hexo generate 顺便也可替换404.html，可以避免一次跳转cp source/404.html public/404.html 然后上传部署，OKhexo deploy Troubleshootinghexo generate的过程可能会报错，可以到[troubleshooting](https://hexo.io/docs/troubleshooting.html)页面查找原因，如页面中含有`{{ }} or {% %}`可能会报错，可以通过用 raw 标签来避免问题123&#123;% raw %&#125;Hello &#123;&#123; sensitive &#125;&#125;&#123;% endraw %&#125;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://juncaixinchi.github.io/Blogs/tags/Blog/"},{"name":"Next","slug":"Next","permalink":"https://juncaixinchi.github.io/Blogs/tags/Next/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://juncaixinchi.github.io/Blogs/tags/GitHub-Pages/"}]},{"title":"Github Git Cheat Sheet","date":"2017-02-12T08:42:19.000Z","path":"2017/02/12/Github-Git-Cheat-Sheet/","text":"GitHub Git 备忘单Git是一个开源的分布式版本控制系统，方便你在笔记本或桌面端进行GitHub的操作，这个备忘单总结了常用的Git命令行指令，以便快速查询。转载自GitHub Git 备忘单要点将所有文件进行快照处理用于版本控制git add * 将文件快照永久地记录在版本历史中git commit -m &quot;upload files&quot; 上传所有本地分支commit到GitHub上git push 安装GitGitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。GitHub for Windowshttp://windows.github.comGitHub for Machttp://mac.github.comGitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取。Git 全平台版http://git-scm.com配置工具对你的commit操作设置关联的用户名$ git config --global user.name &quot;[name]&quot; 对你的commit操作设置关联的邮箱地址$ git config --global user.email &quot;[email address]&quot; 创建仓库创建一个本地的仓库，并设置名字$ git init [project-name] 下载一个项目以及它所有的版本历史$ git clone [url] 更改列出所有新建或者更改的文件，这些文件需要被commit$ git status 展示那些没有暂存文件的差异$ git diff 将文件进行快照处理用于版本控制$ git add [file] 展示暂存文件与最新版本之间的不同$ git diff --staged 将文件移除暂存区，但是保留其内容$ git reset [file] 将文件快照永久地记录在版本历史中$ git commit -m&quot;[descriptive message]&quot; 批量更改列出当前仓库中所有的本地分支$ git branch 建立一个新分支$ git branch [branch-name] 切换到一个特定的分支上并更新工作目录$ git checkout [branch-name] 合并特定分支的历史到当前分支$ git merge [branch-name] 删除特定的分支$ git branch -d [branch-name] 重构文件从工作目录中删除文件并暂存此删除$ git rm [file] 从版本控制中移除文件，但不改变本地文件$ git rm --cached [file] 改变文件名，将其进行快照处理用于版本控制$ git mv [file-original] [file-renamed] 停止追踪文本文件.gitignore可以防止一些特定的文件进入到版本控制中*.log build/ temp-* 列出所有项目中忽略的文件$ git ls-files --others --ignored --exclude-standard 保存临时更改临时存储所有修改的已跟踪文件$ git stash 重新存储所有最近被stash的文件$ git stash pop 列出所有被stash的更改$ git stash list 放弃所有最近stash的更改$ git stash drop 查阅历史列出当前分支的版本历史$ git log 列出文件的版本历史，包括重命名$ git log --follow [file] 展示两个不同分支之间的差异$ git diff [first-branch]...[second-branch] 输出元数据以及特定commit的内容变化$ git show [commit] 撤销commit撤销所有[commit]后的的commit，在本地保存更改$ git reset [commit] 放弃所有更改并回到某个特定的commit$ git reset --hard [commit] 同步更改下载远程仓库的所有历史$ git fetch [remote] 合并远程分支到当前本地分支$ git merge [remote]/[branch] 上传所有本地分支commit到GitHub上$ git push [remote] [branch] 下载远程仓库的所有历史并合并更改$ git pull","tags":[{"name":"Git","slug":"Git","permalink":"https://juncaixinchi.github.io/Blogs/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://juncaixinchi.github.io/Blogs/tags/Github/"},{"name":"Cheat-sheet","slug":"Cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/Cheat-sheet/"}]},{"title":"Todo List","date":"2017-02-12T08:42:01.000Z","path":"2017/02/12/Todo-List/","text":"Todo ListNode/React基于GWAS catalog的基因数据解读爬虫-单词统计-&gt;计算机英语","tags":[{"name":"Blog","slug":"Blog","permalink":"https://juncaixinchi.github.io/Blogs/tags/Blog/"}]},{"title":"Markdown note","date":"2017-02-12T08:41:46.000Z","path":"2017/02/12/Markdown-note/","text":"Markdown语法摘要基本格式标记+空格+内容标题# 一级标题 # ## 二级标题 ### 三级标题 以此类推，共6级标题，后面的#可加可不加或者一级标题 === 二级标题 --- 列表+ 无序列表 - 无序列表 * 无序列表 1. 有序列表 2. 有序列表 引用&gt; 引用 MarkdownPad2快捷键为ctrl+q图片与链接链接：[]() [github](https://github.com) 图片：![]() ![icon](https://juncaixinchi.github.io/juncaixinchi.xyz/favicon.ico) 实例效果：github 或者This is [an example][id] reference-style link. [id]: http://example.com/ &quot;Optional Title Here&quot; 实例:This is an example reference-style link.文本样式*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ 注意必须前后包围，且不连空格样式： 斜体文本 粗体文本代码框使用 ` 符号` code ` Tab和空格Tab或4个空格+code 使用123```javascriptcode分割线*** * * * --- ___ 三个及以上 * 或 - 或 _ ，其间可有空格。样式：需要转义的字符\\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号","tags":[{"name":"Cheat-sheet","slug":"Cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/Cheat-sheet/"},{"name":"Markdown","slug":"Markdown","permalink":"https://juncaixinchi.github.io/Blogs/tags/Markdown/"}]},{"title":"node install note","date":"2017-02-12T08:39:15.000Z","path":"2017/02/12/node-install-note/","text":"Node安装与npm环境变量配置Node安装进入nodejs官方网站下载软件(nodejs.org)Windows环境下的NodeJS+NPM+Bower安装配置Windows环境下的NodeJS+NPM+Bower安装配置下载完成后，双击默认安装。安装程序会自动添加环境变量Windows环境下的NodeJS+NPM+Bower安装配置检测nodejs是否安装成功。打开cmd命令行 输入 node - v 显示当前版本号Windows环境下的NodeJS+NPM+Bower安装配置检查npm是否安装。由于新版的NodeJS已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行中键入 npm -vWindows环境下的NodeJS+NPM+Bower安装配置npm环境变量配置npm作为一个NodeJS的模块管理，之前我由于没有系统地看资料所以导致安装配置模块的时候走了一大段弯路，所以现在很有必要列出来记录下。我们要先配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立“node_global”及“node_cache”两个文件夹。我们就在cmd中键入两行命令：npm config set prefix “D:\\Program Files\\nodejs\\node_global”和npm config set cache “D:\\Program Files\\nodejs\\node_cache”下面这一步非常关键，我们需要设置系统变量。进入我的电脑→属性→高级→环境变量。在系统变量下新建“NODE_PATH”，输入“D:\\Program Files\\nodejs\\node_global\\node_modules”。安装bower, npm install bower -g; -g表示全局输入 node，require(‘bower’) 测试是否安装成功！","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://juncaixinchi.github.io/Blogs/tags/Node-js/"}]},{"title":"Hello Hexo","date":"2017-02-12T08:24:56.000Z","path":"2017/02/12/Hello-Hexo/","text":"Hello Hexo !","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Hexo/"}]},{"title":"Hello World","date":"2017-02-12T08:20:13.445Z","path":"2017/02/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","tags":[{"name":"Cheat-sheet","slug":"Cheat-sheet","permalink":"https://juncaixinchi.github.io/Blogs/tags/Cheat-sheet/"},{"name":"Hexo","slug":"Hexo","permalink":"https://juncaixinchi.github.io/Blogs/tags/Hexo/"}]}]